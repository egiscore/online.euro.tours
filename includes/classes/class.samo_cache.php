<?php
 class Samo_Cache implements ArrayAccess { public $cachetime = 3600; private $storage = null; private $internal = null; private $driver = null; private $lock_key = null; public function __construct($driver = null) { if (null === $driver) { if (!defined('INTERNAL_CACHE_DRIVER') || 'auto' == strtolower(INTERNAL_CACHE_DRIVER)) { $this->driver = 'auto'; if ('cli-server' == PHP_SAPI) { $driver = 'null'; } else { if (extension_loaded('apcu')) { $driver = 'apcu'; } else { if (extension_loaded('memcache')) { $driver = 'memcache'; } else { if (extension_loaded('xcache')) { $driver = 'xcache'; } else { $driver = 'file_serialize'; } } } } } else { $driver = INTERNAL_CACHE_DRIVER; } } $this->driver($driver); $this->internal = array(); $this->lock_key = Samo_Request::host() . '_' . (function_exists('posix_getpid') ? posix_getpid() : getmypid()); } public function internal($key, $value) { if ($this->driver !== 'null') { $this->internal[$key] = $value; } return $value; } public function driver($driver = 'apcu') { $is_auto = $this->driver == 'auto'; if ($this->driver !== $driver || null == $this->storage) { $this->driver = strtolower($driver); $cache_class = ucwords('samo_cache_' . $driver, '_'); try { $cache_class = Samo_Loader::load_class($cache_class); } catch (Samo_Exception $e) { throw new Samo_Cache_Exception('Unknown storage driver: ' . $driver); } $this->storage = Samo_Loader::load_object($cache_class, ['lock_key' => $this->lock_key]); if (!$this->storage instanceof ICacheStorage) { $this->driver('null'); } if (false === $this->storage->supported($error)) { if ($is_auto) { $this->driver('null'); } else { throw new Samo_Cache_Exception($error); } } } return $this->driver; } public function set($offset, $value, $ttl = null, $force = false) { $offset = $this->_offset($offset); $ttl = (null === $ttl) ? $this->cachetime : $ttl; if ($force || $this->storage->lock($offset)) { $this->storage->set($offset, $value, $ttl); if (!$force) { $this->storage->unlock($offset); } } return $this->internal($offset, $value); } public function get($offset) { $offset = $this->_offset($offset); if (isset($this->internal[$offset])) { return $this->internal[$offset]; } if (null !== ($cached = $this->storage->get($offset))) { return $this->internal($offset, $cached); } return false; } public function getOrSet($offset, \Closure $getter, $ttl = null, $force = false) { $_offset = $this->_offset($offset); if (isset($this->internal[$_offset])) { return $this->internal[$_offset]; } if (null !== ($cached = $this->storage->get($_offset))) { return $this->internal($_offset, $cached); } $value = call_user_func($getter, $this); return $this->set($offset, $value, $ttl, $force); } public function offsetExists($offset) { $offset = $this->_offset($offset); return isset($this->internal[$offset]) || $this->storage->exists($offset); } public function offsetGet($offset) { return $this->get($offset); } public function offsetSet($offset, $value) { return $this->set($offset, $value); } public function offsetUnset($offset) { $offset = $this->_offset($offset); if (isset($this->internal[$offset])) { unset($this->internal[$offset]); } return $this->storage->delete($offset); } private function _offset($string) { $prefix = defined('INTERNAL_CACHE_PREFIX') ? INTERNAL_CACHE_PREFIX : ((defined('CUSTOM')) ? CUSTOM : _ROOT); $string = $prefix . ':' . $string; return (strlen($string) > 32) ? md5($string) : $string; } public function purge() { $this->internal = array(); $this->storage->purge(); } public function vacuum() { $this->storage->vacuum(); } } interface ICacheStorage { public function __construct($options = []); public function set($offset, $value, $ttl); public function get($offset); public function exists($offset); public function delete($offset); public function lock($offset); public function unlock($offset); public function purge($ns = null); public function vacuum(); public function supported(&$reason); } class Samo_Cache_File_Serialize implements ICacheStorage { private $cachefile = null; private $cachedir = null; private $now = null; public $cacheext = '.cache'; protected $lock_key = null; private $lock_ttl = 61; public function __construct($options = []) { $this->set_cachedir($options); $this->now = $_SERVER['REQUEST_TIME']; $this->lock_key = isset($options['lock_key']) ? $options['lock_key'] : getmypid(); } protected function set_cachedir($options) { $path = isset($options['cachedir']) ? $options['cachedir'] : (defined('INTERNAL_CACHE_DIR') ? INTERNAL_CACHE_DIR : SMARTY_COMPILE_DIR . '/cache'); if (!file_exists($path)) { $this->cachefile = $path; $this->new_cachedir(); } elseif (is_file($path)) { $this->cachefile = $path; $this->cachedir = file_get_contents($path); } else { $this->cachedir = $path; } } protected function new_cachedir() { $file = $this->cachefile; $dir = $file . '.' . time(); $umask = umask(0); if (@mkdir($dir, 0777, true)) { if (file_put_contents($file, $dir, LOCK_EX)) { chmod($file, 0666); umask($umask); clearstatcache(true, $file); $this->cachedir = $dir; return true; } }; return false; } public function supported(&$reason) { $disable_functions = ini_get('disable_functions'); if (strpos($disable_functions, 'exec') !== false) { $reason = 'exec() has been disabled for security reasons, ' . __CLASS__ . ' is useless'; return false; } if (!is_writable($this->cachedir)) { $reason = $this->cachedir . ' not writable, ' . __CLASS__ . ' is useless'; return false; } return true; } public function offset_path($offset) { $DS = '/'; $_dir = $this->cachedir . $DS; $_dir = str_replace('\\', $DS, $_dir); $_filename = urlencode(basename($offset)); $_crc32 = sprintf('%08X', crc32($offset)); $_dir .= substr($_crc32, 0, 2) . $DS . substr($_crc32, 0, 3) . $DS . $_crc32; if (!file_exists($_dir) && !mkdir($_dir, 0777, true) && !is_dir($_dir)) { return $this->cachedir . $DS . md5($offset); } return $_dir . $DS . $_filename . $this->cacheext; } public function lock($offset) { $file = $this->offset_path($offset) . '.lock'; if (!file_exists($file) || filemtime($file) + $this->lock_ttl < $this->now) { touch($file, $this->now); clearstatcache(true, $file); if (false !== file_put_contents($file, $this->lock_key, LOCK_EX)) { return true; } } return false; } public function unlock($offset) { $file = $this->offset_path($offset) . '.lock'; if (!file_exists($file)) { return false; } if (!filesize($file)) { return false; } if (filemtime($file) + $this->lock_ttl < $this->now) { return @unlink($file); } $locked_by = @file_get_contents($file); if (!$locked_by || $this->lock_key != $locked_by) { return false; } return @unlink($file); } public function exists($offset) { return file_exists($this->offset_path($offset)); } public function set($offset, $value, $ttl) { $file = $this->offset_path($offset); if (file_put_contents($file, $this->compress($value), LOCK_EX)) { $umask = umask(0); touch($file, $this->now + $ttl); chmod($file, 0666); umask($umask); } return $value; } protected function compress($value) { return serialize($value); } protected function uncompress($file) { if ($return = file_get_contents($file)) { return unserialize($return); } return false; } public function get($offset) { $file = $this->offset_path($offset); if (file_exists($file)) { $value = $this->uncompress($file); if (false !== $value && (filemtime($file) >= $this->now || file_exists($file . '.lock'))) { return $value; } } return null; } public function delete($offset) { @unlink($this->offset_path($offset)); } public function purge($ns = null) { if ($this->cachefile) { return $this->new_cachedir(); } return true; } public function vacuum() { return true; } } class Samo_Cache_File_Php extends Samo_Cache_File_Serialize { public $cacheext = '.php'; protected function compress($value) { return '<' . '?php return ' . var_export($value, true) . ';'; } protected function uncompress($file) { return include $file; } } class Samo_Cache_Apcu implements ICacheStorage { private $enabled = true; private $lock_key = null; private $lock_ttl = 61; public function __construct($options = array()) { $this->enabled = ('cli' != PHP_SAPI); $this->lock_key = isset($options['lock_key']) ? $options['lock_key'] : getmypid(); } public function supported(&$reason) { if (!extension_loaded('apcu')) { $reason = 'extension APCu not loaded, ' . __CLASS__ . ' is useless'; return false; } if (!in_array(ini_get('apc.enabled'), array('1', 'On'))) { $reason = 'apc.enabled is 0, ' . __CLASS__ . ' is useless'; return false; } return true; } public function lock($offset) { return @apcu_add($offset . '_lock', $this->lock_key, $this->lock_ttl); } public function unlock($offset) { @apcu_delete($offset . '_lock'); } public function set($offset, $value, $ttl) { apcu_store($offset, $value, $ttl); } public function get($offset) { if ($return = apcu_fetch($offset)) { return $return; } return null; } public function delete($offset) { return apcu_delete($offset); } public function exists($offset) { return apcu_exists($offset); } public function purge($ns = null) { if ($this->enabled) { if (null === $ns) { return apcu_clear_cache(); } else { $cache = apcu_cache_info(); foreach ($cache['cache_list'] as $entry) { if (strpos($entry['info'], $ns) === 0) { apcu_delete($entry['info']); } } } } return true; } public function vacuum() { if ($this->enabled) { $LOW_ACTIVITY = strtotime('-10 minute'); $EXPIRE = $_SERVER['REQUEST_TIME']; if (false !== ($entries = apcu_cache_info())) { foreach ($entries['cache_list'] as $entry) { if ( ($entry['creation_time'] < $LOW_ACTIVITY && $entry['num_hits'] < 10) || (false !== ($data = apcu_fetch($entry['info'])) && $data['expire'] < $EXPIRE) ) { apcu_delete($entry['info']); } } } } return true; } } class Samo_Cache_Apc extends Samo_Cache_Apcu { } class Samo_Cache_Memcache implements ICacheStorage { private $enabled = false; private $memcache = null; private $lock_ttl = 61; private $lock_key = null; public function __construct($options = array()) { $this->lock_key = isset($options['lock_key']) ? $options['lock_key'] : getmypid(); } public function supported(&$reason) { if (!extension_loaded('memcache')) { $reason = 'extension memcache not loaded, ' . __CLASS__ . ' is useless'; return false; } $dsn = defined('INTERNAL_CACHE_MEMCACHE') ? INTERNAL_CACHE_MEMCACHE : '127.0.0.1:11211'; list($host, $port) = explode(':', $dsn); $this->memcache = @memcache_connect($host, $port); if (false !== $this->memcache) { $this->enabled = true; } else { $reason = 'Could not connect to "' . $dsn . '"' . __CLASS__ . ' is useless, check constant INTERNAL_CACHE_MEMCACHE'; return false; } return true; } public function lock($offset) { return @memcache_add($this->memcache, $offset . '_lock', $this->lock_key, 0, $this->lock_ttl); } public function unlock($offset) { $offset = $offset . '.lock'; $locked_by = $this->get($offset); if ($locked_by && $locked_by == $this->lock_key) { return $this->delete($offset); } return false; } public function set($offset, $value, $ttl) { $result = @memcache_set($this->memcache, $offset, $value, MEMCACHE_COMPRESSED, $ttl); return $result; } public function get($offset) { if (false !== ($return = @memcache_get($this->memcache, $offset))) { return $return; } return null; } public function delete($offset) { return memcache_delete($this->memcache, $offset); } public function exists($offset) { return false !== memcache_get($this->memcache, $offset); } public function purge($ns = null) { if ($this->enabled) { return memcache_flush($this->memcache); } return true; } public function vacuum() { return true; } public function __destruct() { if ($this->enabled) { memcache_close($this->memcache); } } } if (extension_loaded('xcache') && !function_exists('xcache_unset_by_prefix')) { function xcache_unset_by_prefix($ns) { xcache_clear_cache(XC_TYPE_VAR, -1); } } class Samo_Cache_XCache implements ICacheStorage { private $enabled = true; private $lock_key = null; private $lock_ttl = 61; public function __construct($options = array()) { $this->enabled = ('cli' != PHP_SAPI); $this->lock_key = isset($options['lock_key']) ? $options['lock_key'] : getmypid(); } public function supported(&$reason) { if (!extension_loaded('xcache')) { $reason = 'extension XCache not loaded, ' . __CLASS__ . ' is useless'; return false; } if ((bool)ini_get('xcache.admin.enable_auth')) { $reason = 'xcache.admin.enable_auth was set in php configuration, ' . __CLASS__ . ' is useless'; return false; } if (0 == ini_get('xcache.var_size')) { $reason = 'xcache.var_size is 0, ' . __CLASS__ . ' is useless'; return false; } return true; } public function lock($offset) { $offset = $offset . '.lock'; if (!xcache_isset($offset)) { return xcache_set($offset, $this->lock_key, $this->lock_ttl); } return false; } public function unlock($offset) { $offset = $offset . '.lock'; if (xcache_isset($offset)) { $locked_by = xcache_get($offset); if ($locked_by == $this->lock_key) { return xcache_unset($offset); } } return false; } public function set($offset, $value, $ttl) { xcache_set($offset, $value, $ttl); } public function get($offset) { if ($return = xcache_get($offset)) { return $return; } return null; } public function delete($offset) { return xcache_unset($offset); } public function exists($offset) { return xcache_isset($offset); } public function purge($ns = null) { if ($this->enabled) { if (null === $ns) { xcache_clear_cache(XC_TYPE_PHP); return xcache_clear_cache(XC_TYPE_VAR, -1); } else { xcache_unset_by_prefix($ns); return true; } } return true; } public function vacuum() { if ($this->enabled) { $LOW_ACTIVITY = strtotime('-10 minute'); $EXPIRE = $_SERVER['REQUEST_TIME']; $count = xcache_count(XC_TYPE_VAR); for ($id = 0; $id < $count; $id++) { if (false !== ($entries = xcache_list(XC_TYPE_VAR, $id))) { foreach ($entries['cache_list'] as $entry) { if ( ($entry['ctime'] < $LOW_ACTIVITY && $entry['hits'] < 10) || (false !== ($data = xcache_get($entry['name'])) && $data['expire'] < $EXPIRE) ) { xcache_unset($entry['info']); } } } } } return true; } } class Samo_Cache_Internal implements ICacheStorage { public function __construct($options = array()) { } public function supported(&$reason) { return true; } public function locked($offset) { return false; } public function lock($offset) { return false; } public function unlock($offset) { return false; } public function set($offset, $value, $ttl) { return false; } public function get($offset) { return null; } public function delete($offset) { return false; } public function exists($offset) { return false; } public function purge($ns = null) { return true; } public function vacuum() { return false; } } class Samo_Cache_Null extends Samo_Cache_Internal { } class Samo_Cache_Exception extends Samo_Exception { } 