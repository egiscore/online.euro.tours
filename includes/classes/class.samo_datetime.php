<?php
 class Samo_Datetime implements Serializable { private $nullable = true; private $datetime = null; private $lazy = null; private $format = 'd.m.Y'; public function serialize() { return serialize( array( 'lazy' => (null == $this->lazy) ? $this->format('sqldatetime') : $this->lazy, 'nullable' => $this->nullable, ) ); } public function unserialize($data) { $vars = unserialize($data); foreach ($vars as $key => $value) { $this->{$key} = $value; } } public function __construct($mixed = null, $check = true) { if (null === $mixed || $mixed instanceof NullDateTime || ($mixed instanceof Samo_Datetime && $mixed->is_null())) { $this->datetime = null; $this->nullable = true; } elseif ((is_string($mixed) && !empty($mixed)) || is_int($mixed)) { $this->lazy = ($check) ? $this->check($mixed) : $mixed; $this->nullable = false; } elseif ($mixed instanceof Samo_Datetime) { $this->datetime = $mixed->getDateTime(); $this->nullable = false; } elseif ($mixed instanceof Datetime) { $this->datetime = $mixed; $this->nullable = false; } } public function is_null() { return $this->nullable; } public function not_null() { return !$this->nullable; } private function load_messages() { $registry = Samo_Registry::instance(); if (isset($registry['messages'])) { $messages = $registry['messages']; if (isset($messages['DATETIME_FORMAT_REPLACEMENTS']) && is_array($messages['DATETIME_FORMAT_REPLACEMENTS'])) { $messages = $messages['DATETIME_FORMAT_REPLACEMENTS']; return $messages; } } return false; } public function localization($format) { $replacement = []; if (self::lang() != 'rus') { $format = str_replace('f', 'F', $format); } if (self::lang() != 'eng') { $eng = array(); $eng['l'] = array('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'); $eng['F'] = array('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'); $eng['M'] = array('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'); $eng['D'] = array('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'); if ($localized = $this->load_messages()) { foreach (array_keys($eng) as $placeholder) { if (strpos($format, $placeholder) !== false) { $replacement = array_merge($replacement, array_combine($eng[$placeholder], $localized[$placeholder])); } } if (strpos($format, 'f') !== false) { $format = str_replace('f', 'F', $format); $replacement = array_merge($replacement, array_combine($eng['F'], $localized['f'])); } } } return [$format, $replacement]; } public function format($format = '') { if ($this->is_null()) { return null; } if (in_array($format, array('sql', 'sqldatetime'))) { $this->check_sql(); } switch ($format) { case 'sql': $format = 'Ymd'; break; case 'xml': $format = 'Y-m-d'; break; case 'xmldatetime': $format = 'Y-m-d\TH:i:s'; break; case 'sqldatetime': $format = 'Y-m-d H:i:s'; break; case 'smartdatetime': $now = self::now(); $diff = abs($this->diff($now)); if ($diff <= 1) { if ($diff == 1 || (int)$this->datetime()->format('H') > (int)self::now()->format('H')) { $format = 'j M H:i'; } else { $format = 'H:i'; } } elseif ($diff < 90) { $format = 'j M'; } else { $format = 'd.m.Y'; } break; case 'datetime': $format = 'd.m.Y H:i'; if ('00:00' == $this->datetime()->format('H:i')) { $format = 'd.m.Y'; } break; case 'time': $format = 'H:i'; break; case 'date': case '': $format = 'd.m.Y'; break; case 'age': $today = $this->today(); return ($this->format('md') > $today->format('md')) ? $today->format('Y') - $this->format('Y') - 1 : $today->format('Y') - $this->format('Y'); default: break; } list($format, $replacement) = $this->localization($format); $result = $this->datetime()->format($format); return strtr($result, $replacement); } private function check_sql() { $min_date = new \DateTime('1900-01-01'); if ($this->lt($min_date)) { $this->datetime = $min_date; } $max_date = new \DateTime('2079-06-06'); if ($this->gt($max_date)) { $this->datetime = $max_date; } } public function datetime() { if (null !== $this->lazy) { try { $dtz = new \DateTimeZone(date_default_timezone_get()); $this->datetime = new \Datetime($this->lazy, $dtz); if (strpos($this->lazy, '@') === 0) { $offset = $this->datetime->getOffset(); $this->datetime->setTimezone($dtz); $this->datetime->modify('+' . $offset . ' second'); } $this->nullable = false; } catch (\Exception $e) { $this->datetime = null; $this->nullable = true; } $this->lazy = null; } return ($this->nullable) ? new NullDateTime() : $this->datetime; } static public function today() { return new self('today'); } static public function now() { return new self('now'); } static public function null() { return new self(); } public function diff($date = null) { $date = (null === $date) ? new \DateTime('today') : $date; if ($date instanceof Samo_Datetime) { $date = $date->getDateTime(); } $diff = $this->datetime()->diff($date); return (($diff->invert) ? 1 : -1) * $diff->days; } private function param2datetime($param = null) { if ($param instanceof \Datetime) { return $param; } if ($param instanceof Samo_Datetime) { return $param->getDateTime(); } if (null === $param) { return new \Datetime('today'); } return self::parse($param); } public function lt($date = null) { $diff = $this->diff($this->param2datetime($date)); return $diff < 0; } public function lte($date = null) { return $this->diff($this->param2datetime($date)) <= 0; } public function gt($date = null) { return $this->diff($this->param2datetime($date)) > 0; } public function gte($date = null) { return $this->diff($this->param2datetime($date)) >= 0; } public function eq($date = null) { $days = $this->diff($this->param2datetime($date)); return $days == 0; } public function ne($date = null) { return !$this->eq($date); } public function modify($modify) { try { $this->datetime()->modify($modify); } catch (Exception $e) { throw new Samo_Exception( "wrong time modification string '{$modify}'" ); } return $this; } public function add_days($days) { return (intval($days)) ? $this->modify($days . ' day') : $this; } public function __toString() { $datetime = $this->datetime(); return $datetime->format($this->format); } public function __clone() { if ($this->not_null()) { $this->datetime = clone $this->datetime(); } } public function copy() { return clone $this; } public function getDateTime() { return $this->datetime(); } public static function check($date) { if ($date && is_string($date)) { $date = preg_replace('~^(\d{2})\/(\d{2})(\/.+)~', '\2/\1\3', $date); if ( preg_match('~^(\d{4})[-\.](\d{2})[-\.](\d{2})~', $date, $matches) ) { if (!checkdate($matches[2], $matches[3], $matches[1])) { return false; } else { return preg_replace('~^(\d{4})[-\.](\d{2})[-\.](\d{2})(.+)~', '\2/\3/\1\4', $date); } } elseif ( preg_match('~^(\d{2})[-\.](\d{2})[-\.](\d{4})~', $date, $matches) ) { if (!checkdate($matches[2], $matches[1], $matches[3])) { if (!checkdate($matches[1], $matches[2], $matches[3])) { return false; } else { return preg_replace('~^(\d{2})[-\.](\d{2})[-\.](\d{4})(.+)~', '\1/\2/\3\4', $date); } } else { return preg_replace('~^(\d{2})[-\.](\d{2})[-\.](\d{4})(.+)~', '\2/\1/\3\4', $date); } } } if (is_int($date) || is_numeric($date)) { if (strlen($date) == 8) { return $date; } if (strlen($date) > 10) { $date = round($date / 1000); } return "@{$date}"; } if (false === date_create($date)) { return false; } return $date; } public function is_smalldatetime() { $min_date = new \DateTime('1900-01-01'); if ($this->lt($min_date)) { return false; } $max_date = new \DateTime('2079-06-06'); if ($this->gt($max_date)) { return false; } return true; } public static function parse($date) { if ($date instanceof Samo_Datetime) { return $date; } if ($date instanceof \DateTime) { return new self($date, false); } if ($date instanceof NullDateTime) { return Samo_Datetime::null(); } if (false !== ($_date = self::check($date))) { return new self($_date, false); } throw new Samo_Exception("Argument {$date} look like not date"); } static public function period($days) { $date = self::today(); return ($days) ? $date->add_days($days) : $date; } static public function __set_state($params) { if ($params['lazy']) { return new Samo_Datetime($params['lazy']); } elseif ($params['datetime'] && !$params['nullable']) { return new Samo_Datetime($params['datetime']); } return new NullDateTime(); } public function zeroTime() { if ($this->lazy) { $this->lazy = trim(preg_replace('~\s+?\d{2}:\d{2}:\d{2}~', '', $this->lazy)); } else { $this->datetime()->setTime(0, 0, 0); } return $this; } static public function lang($lang = null) { static $LANG = null; if (null !== $lang) { $LANG = $lang; } return $LANG; } static public function stringify($param) { if (is_array($param)) { return array_map('Samo_DateTime::stringify', $param); } elseif ($param instanceof Samo_Datetime) { return $param->__toString(); } elseif ($param instanceof NullDateTime) { return 'null'; } return $param; } } class NullDateTime extends DateTime { public function format($format = '') { return ''; } public function is_null() { return true; } public function not_null() { return false; } public function __toString() { return ''; } } 