<?php
 class Samo_Pdf extends FPDF { protected $page_numbers = false; protected $pnumber_font_size = 8; protected $pnumber_font_name = 'courier'; protected $outlines = array(); protected $OutlineRoot; protected $T128 = array(); protected $Aset = ''; protected $SetFrom = ''; protected $SetTo = ''; protected $JStart = array('A' => 103, 'B' => 104, 'C' => 105); protected $JSwap = array('A' => 101, 'B' => 100, 'C' => 99); protected $widths = array(); protected $aligns = array(); protected $encrypted = false; protected $Uvalue; protected $Ovalue; protected $Pvalue; protected $enc_obj_id; protected $last_rc4_key = ''; protected $last_rc4_key_c; protected $default_font = 'courier'; protected $encryption_key = null; public $header_handler = null; public $footer_handler = null; public function __construct($orientation = 'P', $unit = 'mm', $size = 'A4') { parent::__construct($orientation, $unit, $size); $this->CoreFonts[] = 'arial'; $this->padding = "\x28\xBF\x4E\x5E\x4E\x75\x8A\x41\x64\x00\x4E\x56\xFF\xFA\x01\x08" . "\x2E\x2E\x00\xB6\xD0\x68\x3E\x80\x2F\x0C\xA9\xFE\x64\x53\x69\x7A"; $this->SetAutoPageBreak(true, 5); } public function default_font($font = null) { if (!is_null($font)) { $this->default_font = $font; } return $this->default_font; } public function SetFont($family, $style = '', $size = 0) { parent::SetFont($family, $style, $size); if (substr($family, strlen($family) - 1, strlen($family)) == 'b') { $this->default_font = substr($family, 0, strlen($family) - 1); } else { $this->default_font = $family; } $this->pnumber_font_size = $size; } public function page_numbers($use = null, $font_name = 'courier', $font_size = 8) { if (!is_null($use)) { $this->page_numbers = $use; $this->pnumber_font_name = $font_name; $this->pnumber_font_size = $font_size; } return $this->page_numbers; } public function title($title) { $this->SetTitle($title); } public function page() { $this->AddPage(); $this->SetXY(0, 0); $this->Ln(); } public function h1($text, $w = 0) { $this->SetFont($this->default_font, '', 14); $this->br(); $this->Cell($w, 20, $text, 0, 2, 'C', 0); } public function h2($text, $w = 0) { $this->SetFont($this->default_font, '', 9); $this->Cell($w, 15, $text, 0, 2, 'C', 0); } public function p($text, $font_size = 8, $w = 0, $h = 3, $al = 'J', $border = 0) { $this->SetFont($this->default_font, '', $font_size); $this->MultiCell($w, $h, $text, $border, $al, 0); } public function br() { $this->Ln(); } public function Header() { if ($this->header_handler) { call_user_func($this->header_handler, $this); } } public function Footer() { if ($this->footer_handler) { call_user_func($this->footer_handler, $this); } if ($this->page_numbers) { $this->SetY(-10); $this->SetFont($this->pnumber_font_name, '', $this->pnumber_font_size); $this->Cell(0, 10, $this->PageNo(), 0, 0, 'C'); } } public function Bookmark($txt, $level = 0, $y = 0) { if ($y == -1) { $y = $this->GetY(); } $this->outlines[] = array('t' => iconv("CP1251", "UTF-16", $txt), 'l' => $level, 'y' => ($this->h - $y) * $this->k, 'p' => $this->PageNo()); } public function _putbookmarks() { $nb = count($this->outlines); if ($nb == 0) { return; } $lru = array(); $level = 0; foreach ($this->outlines as $i => $o) { if ($o['l'] > 0) { $parent = $lru[$o['l'] - 1]; $this->outlines[$i]['parent'] = $parent; $this->outlines[$parent]['last'] = $i; if ($o['l'] > $level) { $this->outlines[$parent]['first'] = $i; } } else { $this->outlines[$i]['parent'] = $nb; } if ($o['l'] <= $level and $i > 0) { $prev = $lru[$o['l']]; $this->outlines[$prev]['next'] = $i; $this->outlines[$i]['prev'] = $prev; } $lru[$o['l']] = $i; $level = $o['l']; } $n = $this->n + 1; foreach ($this->outlines as $i => $o) { $this->_newobj(); $this->_out('<</Title ' . $this->_textstring($o['t'])); $this->_out('/Parent ' . ($n + $o['parent']) . ' 0 R'); if (isset($o['prev'])) { $this->_out('/Prev ' . ($n + $o['prev']) . ' 0 R'); } if (isset($o['next'])) { $this->_out('/Next ' . ($n + $o['next']) . ' 0 R'); } if (isset($o['first'])) { $this->_out('/First ' . ($n + $o['first']) . ' 0 R'); } if (isset($o['last'])) { $this->_out('/Last ' . ($n + $o['last']) . ' 0 R'); } $this->_out(sprintf('/Dest [%d 0 R /XYZ 0 %.2F null]', 1 + 2 * $o['p'], $o['y'])); $this->_out('/Count 0>>'); $this->_out('endobj'); } $this->_newobj(); $this->OutlineRoot = $this->n; $this->_out('<</Type /Outlines /First ' . $n . ' 0 R'); $this->_out('/Last ' . ($n + $lru[0]) . ' 0 R>>'); $this->_out('endobj'); } public $wLine; public $hLine; public $Text; public $border; public $align; public $fill; public $Padding; public $lPadding; public $tPadding; public $bPadding; public $rPadding; public $TagStyle; public $Indent; public $Space; public $PileStyle; public $Line2Print; public $NextLineBegin; public $TagName; public $Delta; public $StringLength; public $LineLength; public $wTextLine; public $nbSpace; public $Xini; public $href; public $TagHref; public $LastLine; public function WriteTag($w, $h, $txt, $border = 0, $align = "J", $fill = false, $padding = 0) { $this->wLine = $w; $this->hLine = $h; $this->Text = trim($txt); $this->Text = preg_replace("/\n|\r|\t/", "", $this->Text); $this->border = $border; $this->align = $align; $this->fill = $fill; $this->Padding = $padding; $this->Xini = $this->GetX(); $this->href = ""; $this->PileStyle = array(); $this->TagHref = array(); $this->LastLine = false; $this->SetSpace(); $this->Padding(); $this->LineLength(); $this->BorderTop(); while ($this->Text != "") { $this->MakeLine(); $this->PrintLine(); } $this->BorderBottom(); } public function SetStyle($tag, $style, $family = null, $size = null, $color = "0,0,0", $indent = -1) { $tag = trim($tag); $this->TagStyle[$tag]['family'] = !is_null($family) ? trim($family) : null; $this->TagStyle[$tag]['style'] = trim($style); $this->TagStyle[$tag]['size'] = !is_null($size) ? trim($size) : null; $this->TagStyle[$tag]['color'] = trim($color); $this->TagStyle[$tag]['indent'] = $indent; } public function SetSpace() { $tag = $this->Parser($this->Text); $this->FindStyle($tag[2], 0); $this->DoStyle(0); $this->Space = $this->GetStringWidth(" "); } public function Padding() { if (preg_match("/^.+,/", $this->Padding)) { $tab = explode(",", $this->Padding); $this->lPadding = $tab[0]; $this->tPadding = $tab[1]; if (isset($tab[2])) { $this->bPadding = $tab[2]; } else { $this->bPadding = $this->tPadding; } if (isset($tab[3])) { $this->rPadding = $tab[3]; } else { $this->rPadding = $this->lPadding; } } else { $this->lPadding = 1; $this->tPadding = $this->Padding; $this->bPadding = $this->Padding; $this->rPadding = 1; } if ($this->tPadding < $this->LineWidth) { $this->tPadding = $this->LineWidth; } } public function LineLength() { if ($this->wLine == 0) { $this->wLine = $this->w - $this->Xini - $this->rMargin; } $this->wTextLine = $this->wLine - $this->lPadding - $this->rPadding; } public function BorderTop() { $border = 0; if ($this->border == 1) { $border = "TLR"; } $this->Cell($this->wLine, $this->tPadding, "", $border, 0, 'C', $this->fill); $y = $this->GetY() + $this->tPadding; $this->SetXY($this->Xini, $y); } public function BorderBottom() { $border = 0; if ($this->border == 1) { $border = "BLR"; } $this->Cell($this->wLine, $this->bPadding, "", $border, 0, 'C', $this->fill); } public function DoStyle($tag) { $tag = trim($tag); parent::SetFont( !is_null($this->TagStyle[$tag]['family']) ? trim($this->TagStyle[$tag]['family']) : $this->default_font, $this->TagStyle[$tag]['style'], !is_null($this->TagStyle[$tag]['size']) ? trim($this->TagStyle[$tag]['size']) : $this->pnumber_font_size ); $tab = explode(",", $this->TagStyle[$tag]['color']); if (count($tab) == 1) { $this->SetTextColor($tab[0]); } else { $this->SetTextColor($tab[0], $tab[1], $tab[2]); } } public function FindStyle($tag, $ind) { $tag = trim($tag); if (!is_null($this->TagStyle[$tag]['family'])) { if ($this->TagStyle[$tag]['family'] != "") { $family = $this->TagStyle[$tag]['family']; } else { reset($this->PileStyle); while (list($k, $val) = each($this->PileStyle)) { $val = trim($val); if ($this->TagStyle[$val]['family'] != "") { $family = $this->TagStyle[$val]['family']; break; } } } } else { $family = $this->default_font; } $style = ""; $style1 = strtoupper($this->TagStyle[$tag]['style']); if ($style1 != "N") { $bold = false; $italic = false; $underline = false; reset($this->PileStyle); while (list($k, $val) = each($this->PileStyle)) { $val = trim($val); $style1 = strtoupper($this->TagStyle[$val]['style']); if ($style1 == "N") { break; } else { if (strpos($style1, "B") !== false) { $bold = true; } if (strpos($style1, "I") !== false) { $italic = true; } if (strpos($style1, "U") !== false) { $underline = true; } } } if ($bold) { $style .= "B"; } if ($italic) { $style .= "I"; } if ($underline) { $style .= "U"; } } if (!is_null($this->TagStyle[$tag]['size'])) { if ($this->TagStyle[$tag]['size'] != 0) { $size = $this->TagStyle[$tag]['size']; } else { reset($this->PileStyle); while (list($k, $val) = each($this->PileStyle)) { $val = trim($val); if ($this->TagStyle[$val]['size'] != 0) { $size = $this->TagStyle[$val]['size']; break; } } } } else { $size = $this->pnumber_font_size; } if ($this->TagStyle[$tag]['color'] != "") { $color = $this->TagStyle[$tag]['color']; } else { reset($this->PileStyle); while (list($k, $val) = each($this->PileStyle)) { $val = trim($val); if ($this->TagStyle[$val]['color'] != "") { $color = $this->TagStyle[$val]['color']; break; } } } $this->TagStyle[$ind]['family'] = $family; $this->TagStyle[$ind]['style'] = $style; $this->TagStyle[$ind]['size'] = $size; $this->TagStyle[$ind]['color'] = $color; $this->TagStyle[$ind]['indent'] = $this->TagStyle[$tag]['indent']; } public function Parser($text) { $tab = array(); if (preg_match("|^(</([^>]+)>)|", $text, $regs)) { $tab[1] = "c"; $tab[2] = trim($regs[2]); } else { if (preg_match("|^(<([^>]+)>)|", $text, $regs)) { $regs[2] = preg_replace("/^a/", "a ", $regs[2]); $tab[1] = "o"; $tab[2] = trim($regs[2]); if (preg_match("/(.+) (.+)='(.+)'/", $regs[2])) { $tab1 = preg_split("/ +/", $regs[2]); $tab[2] = trim($tab1[0]); while (list($i, $couple) = each($tab1)) { if ($i > 0) { $tab2 = explode("=", $couple); $tab2[0] = trim($tab2[0]); $tab2[1] = trim($tab2[1]); $end = strlen($tab2[1]) - 2; $tab[$tab2[0]] = substr($tab2[1], 1, $end); } } } } else { if (preg_match("/^( )/", $text, $regs)) { $tab[1] = "s"; $tab[2] = ' '; } else { if (preg_match("/^([^< ]+)/", $text, $regs)) { if ($this->GetStringWidth($regs[1]) > $this->wTextLine) { $tab[1] = "t"; $k = 1; $tmp = $regs[1]; while ($this->GetStringWidth($tmp) > $this->wTextLine) { $tmp = substr($tmp, 0, strlen($regs[1]) - $k); $k++; } $regs[1] = $tab[2] = trim($tmp); } else { $tab[1] = "t"; $tab[2] = trim($regs[1]); } } } } } $begin = strlen($regs[1]); $end = strlen($text); $text = substr($text, $begin, $end); $tab[0] = $text; return $tab; } public function MakeLine() { $this->Text .= " "; $this->LineLength = array(); $this->TagHref = array(); $Length = 0; $this->nbSpace = 0; $i = $this->BeginLine(); $this->TagName = array(); if ($i == 0) { $Length = $this->StringLength[0]; $this->TagName[0] = 1; $this->TagHref[0] = $this->href; } while ($Length < $this->wTextLine) { $tab = $this->Parser($this->Text); $this->Text = $tab[0]; if ($this->Text == "") { $this->LastLine = true; break; } if ($tab[1] == "o") { array_unshift($this->PileStyle, $tab[2]); $this->FindStyle($this->PileStyle[0], $i + 1); $this->DoStyle($i + 1); $this->TagName[$i + 1] = 1; if ($this->TagStyle[$tab[2]]['indent'] != -1) { $Length += $this->TagStyle[$tab[2]]['indent']; $this->Indent = $this->TagStyle[$tab[2]]['indent']; } if ($tab[2] == "a") { $this->href = $tab['href']; } } if ($tab[1] == "c") { array_shift($this->PileStyle); if (isset($this->PileStyle[0])) { $this->FindStyle($this->PileStyle[0], $i + 1); $this->DoStyle($i + 1); } $this->TagName[$i + 1] = 1; if ($this->TagStyle[$tab[2]]['indent'] != -1) { $this->LastLine = true; $this->Text = trim($this->Text); break; } if ($tab[2] == "a") { $this->href = ""; } } if ($tab[1] == "s") { $i++; $Length += $this->Space; $this->Line2Print[$i] = ""; if ($this->href != "") { $this->TagHref[$i] = $this->href; } } if ($tab[1] == "t") { $i++; $this->StringLength[$i] = $this->GetStringWidth($tab[2]); $Length += $this->StringLength[$i]; $this->LineLength[$i] = $Length; $this->Line2Print[$i] = $tab[2]; if ($this->href != "") { $this->TagHref[$i] = $this->href; } } } trim($this->Text); if ($Length > $this->wTextLine || $this->LastLine == true) { $this->EndLine(); } } public function BeginLine() { $this->Line2Print = array(); $this->StringLength = array(); if (isset($this->PileStyle[0])) { $this->FindStyle($this->PileStyle[0], 0); $this->DoStyle(0); } if (count($this->NextLineBegin) > 0) { $this->Line2Print[0] = $this->NextLineBegin['text']; $this->StringLength[0] = $this->NextLineBegin['length']; $this->NextLineBegin = array(); $i = 0; } else { preg_match("/^(( *(<([^>]+)>)* *)*)(.*)/", $this->Text, $regs); $regs[1] = str_replace(" ", "", $regs[1]); $this->Text = $regs[1] . $regs[5]; $i = -1; } return $i; } public function EndLine() { if (end($this->Line2Print) != "" && $this->LastLine == false) { $this->NextLineBegin['text'] = array_pop($this->Line2Print); $this->NextLineBegin['length'] = end($this->StringLength); array_pop($this->LineLength); } while (end($this->Line2Print) === "") { array_pop($this->Line2Print); } $this->Delta = $this->wTextLine - end($this->LineLength); $this->nbSpace = 0; $iterations = count($this->Line2Print); for ($i = 0; $i < $iterations; $i++) { if ($this->Line2Print[$i] == "") { $this->nbSpace++; } } } public function PrintLine() { $border = 0; if ($this->border == 1) { $border = "LR"; } $this->Cell($this->wLine, $this->hLine, "", $border, 0, 'C', $this->fill); $y = $this->GetY(); $this->SetXY($this->Xini + $this->lPadding, $y); if ($this->Indent != -1) { if ($this->Indent != 0) { $this->Cell($this->Indent, $this->hLine); } $this->Indent = -1; } $space = $this->LineAlign(); $this->DoStyle(0); $iterations = count($this->Line2Print); for ($i = 0; $i < $iterations; $i++) { if (isset($this->TagName[$i])) { $this->DoStyle($i); } if (isset($this->TagHref[$i])) { $href = $this->TagHref[$i]; } else { $href = ''; } if ($this->Line2Print[$i] == "") { $this->Cell($space, $this->hLine, "         ", 0, 0, 'C', false, $href); } else { $this->Cell($this->StringLength[$i], $this->hLine, $this->Line2Print[$i], 0, 0, 'C', false, $href); } } $this->LineBreak(); if ($this->LastLine && $this->Text != "") { $this->EndParagraph(); } $this->LastLine = false; } public function LineAlign() { $space = $this->Space; if ($this->align == "J") { if ($this->nbSpace != 0) { $space = $this->Space + ($this->Delta / $this->nbSpace); } if ($this->LastLine) { $space = $this->Space; } } if ($this->align == "R") { $this->Cell($this->Delta, $this->hLine); } if ($this->align == "C") { $this->Cell($this->Delta / 2, $this->hLine); } return $space; } public function LineBreak() { $x = $this->Xini; $y = $this->GetY() + $this->hLine; $this->SetXY($x, $y); } public function EndParagraph() { $border = 0; if ($this->border == 1) { $border = "LR"; } $this->Cell($this->wLine, $this->hLine / 2, "", $border, 0, 'C', $this->fill); $x = $this->Xini; $y = $this->GetY(); $this->SetXY($x, $y); } public function _putresources() { parent::_putresources(); $this->_putbookmarks(); $this->_putencryptedresources(); } public function _putcatalog() { parent::_putcatalog(); if (count($this->outlines) > 0) { $this->_out('/Outlines ' . $this->OutlineRoot . ' 0 R'); $this->_out('/PageMode /UseOutlines'); } } public function StartTransform() { $this->_out('q'); } public function ScaleX($s_x, $x = '', $y = '') { $this->Scale($s_x, 100, $x, $y); } public function ScaleY($s_y, $x = '', $y = '') { $this->Scale(100, $s_y, $x, $y); } public function ScaleXY($s, $x = '', $y = '') { $this->Scale($s, $s, $x, $y); } public function Scale($s_x, $s_y, $x = '', $y = '') { if ($x === '') { $x = $this->x; } if ($y === '') { $y = $this->y; } if ($s_x == 0 || $s_y == 0) { $this->Error('Please use values unequal to zero for Scaling'); } $y = ($this->h - $y) * $this->k; $x *= $this->k; $s_x /= 100; $s_y /= 100; $tm[0] = $s_x; $tm[1] = 0; $tm[2] = 0; $tm[3] = $s_y; $tm[4] = $x * (1 - $s_x); $tm[5] = $y * (1 - $s_y); $this->Transform($tm); } public function MirrorH($x = '') { $this->Scale(-100, 100, $x); } public function MirrorV($y = '') { $this->Scale(100, -100, '', $y); } public function MirrorP($x = '', $y = '') { $this->Scale(-100, -100, $x, $y); } public function MirrorL($angle = 0, $x = '', $y = '') { $this->Scale(-100, 100, $x, $y); $this->Rotate(-2 * ($angle - 90), $x, $y); } public function TranslateX($t_x) { $this->Translate($t_x, 0); } public function TranslateY($t_y) { $this->Translate(0, $t_y); } public function Translate($t_x, $t_y) { $tm[0] = 1; $tm[1] = 0; $tm[2] = 0; $tm[3] = 1; $tm[4] = $t_x * $this->k; $tm[5] = -$t_y * $this->k; $this->Transform($tm); } public function Rotate($angle, $x = '', $y = '') { if ($x === '') { $x = $this->x; } if ($y === '') { $y = $this->y; } $y = ($this->h - $y) * $this->k; $x *= $this->k; $tm[0] = cos(deg2rad($angle)); $tm[1] = sin(deg2rad($angle)); $tm[2] = -$tm[1]; $tm[3] = $tm[0]; $tm[4] = $x + $tm[1] * $y - $tm[0] * $x; $tm[5] = $y - $tm[0] * $y - $tm[1] * $x; $this->Transform($tm); } public function SkewX($angle_x, $x = '', $y = '') { $this->Skew($angle_x, 0, $x, $y); } public function SkewY($angle_y, $x = '', $y = '') { $this->Skew(0, $angle_y, $x, $y); } public function Skew($angle_x, $angle_y, $x = '', $y = '') { if ($x === '') { $x = $this->x; } if ($y === '') { $y = $this->y; } if ($angle_x <= -90 || $angle_x >= 90 || $angle_y <= -90 || $angle_y >= 90) { $this->Error('Please use values between -90° and 90° for skewing'); } $x *= $this->k; $y = ($this->h - $y) * $this->k; $tm[0] = 1; $tm[1] = tan(deg2rad($angle_y)); $tm[2] = tan(deg2rad($angle_x)); $tm[3] = 1; $tm[4] = -$tm[2] * $y; $tm[5] = -$tm[1] * $x; $this->Transform($tm); } public function Transform($tm) { $this->_out(sprintf('%.3f %.3f %.3f %.3f %.3f %.3f cm', $tm[0], $tm[1], $tm[2], $tm[3], $tm[4], $tm[5])); } public function StopTransform() { $this->_out('Q'); } private function code128A_init() { if (count($this->T128)) { return; } $this->T128[] = array(2, 1, 2, 2, 2, 2); $this->T128[] = array(2, 2, 2, 1, 2, 2); $this->T128[] = array(2, 2, 2, 2, 2, 1); $this->T128[] = array(1, 2, 1, 2, 2, 3); $this->T128[] = array(1, 2, 1, 3, 2, 2); $this->T128[] = array(1, 3, 1, 2, 2, 2); $this->T128[] = array(1, 2, 2, 2, 1, 3); $this->T128[] = array(1, 2, 2, 3, 1, 2); $this->T128[] = array(1, 3, 2, 2, 1, 2); $this->T128[] = array(2, 2, 1, 2, 1, 3); $this->T128[] = array(2, 2, 1, 3, 1, 2); $this->T128[] = array(2, 3, 1, 2, 1, 2); $this->T128[] = array(1, 1, 2, 2, 3, 2); $this->T128[] = array(1, 2, 2, 1, 3, 2); $this->T128[] = array(1, 2, 2, 2, 3, 1); $this->T128[] = array(1, 1, 3, 2, 2, 2); $this->T128[] = array(1, 2, 3, 1, 2, 2); $this->T128[] = array(1, 2, 3, 2, 2, 1); $this->T128[] = array(2, 2, 3, 2, 1, 1); $this->T128[] = array(2, 2, 1, 1, 3, 2); $this->T128[] = array(2, 2, 1, 2, 3, 1); $this->T128[] = array(2, 1, 3, 2, 1, 2); $this->T128[] = array(2, 2, 3, 1, 1, 2); $this->T128[] = array(3, 1, 2, 1, 3, 1); $this->T128[] = array(3, 1, 1, 2, 2, 2); $this->T128[] = array(3, 2, 1, 1, 2, 2); $this->T128[] = array(3, 2, 1, 2, 2, 1); $this->T128[] = array(3, 1, 2, 2, 1, 2); $this->T128[] = array(3, 2, 2, 1, 1, 2); $this->T128[] = array(3, 2, 2, 2, 1, 1); $this->T128[] = array(2, 1, 2, 1, 2, 3); $this->T128[] = array(2, 1, 2, 3, 2, 1); $this->T128[] = array(2, 3, 2, 1, 2, 1); $this->T128[] = array(1, 1, 1, 3, 2, 3); $this->T128[] = array(1, 3, 1, 1, 2, 3); $this->T128[] = array(1, 3, 1, 3, 2, 1); $this->T128[] = array(1, 1, 2, 3, 1, 3); $this->T128[] = array(1, 3, 2, 1, 1, 3); $this->T128[] = array(1, 3, 2, 3, 1, 1); $this->T128[] = array(2, 1, 1, 3, 1, 3); $this->T128[] = array(2, 3, 1, 1, 1, 3); $this->T128[] = array(2, 3, 1, 3, 1, 1); $this->T128[] = array(1, 1, 2, 1, 3, 3); $this->T128[] = array(1, 1, 2, 3, 3, 1); $this->T128[] = array(1, 3, 2, 1, 3, 1); $this->T128[] = array(1, 1, 3, 1, 2, 3); $this->T128[] = array(1, 1, 3, 3, 2, 1); $this->T128[] = array(1, 3, 3, 1, 2, 1); $this->T128[] = array(3, 1, 3, 1, 2, 1); $this->T128[] = array(2, 1, 1, 3, 3, 1); $this->T128[] = array(2, 3, 1, 1, 3, 1); $this->T128[] = array(2, 1, 3, 1, 1, 3); $this->T128[] = array(2, 1, 3, 3, 1, 1); $this->T128[] = array(2, 1, 3, 1, 3, 1); $this->T128[] = array(3, 1, 1, 1, 2, 3); $this->T128[] = array(3, 1, 1, 3, 2, 1); $this->T128[] = array(3, 3, 1, 1, 2, 1); $this->T128[] = array(3, 1, 2, 1, 1, 3); $this->T128[] = array(3, 1, 2, 3, 1, 1); $this->T128[] = array(3, 3, 2, 1, 1, 1); $this->T128[] = array(3, 1, 4, 1, 1, 1); $this->T128[] = array(2, 2, 1, 4, 1, 1); $this->T128[] = array(4, 3, 1, 1, 1, 1); $this->T128[] = array(1, 1, 1, 2, 2, 4); $this->T128[] = array(1, 1, 1, 4, 2, 2); $this->T128[] = array(1, 2, 1, 1, 2, 4); $this->T128[] = array(1, 2, 1, 4, 2, 1); $this->T128[] = array(1, 4, 1, 1, 2, 2); $this->T128[] = array(1, 4, 1, 2, 2, 1); $this->T128[] = array(1, 1, 2, 2, 1, 4); $this->T128[] = array(1, 1, 2, 4, 1, 2); $this->T128[] = array(1, 2, 2, 1, 1, 4); $this->T128[] = array(1, 2, 2, 4, 1, 1); $this->T128[] = array(1, 4, 2, 1, 1, 2); $this->T128[] = array(1, 4, 2, 2, 1, 1); $this->T128[] = array(2, 4, 1, 2, 1, 1); $this->T128[] = array(2, 2, 1, 1, 1, 4); $this->T128[] = array(4, 1, 3, 1, 1, 1); $this->T128[] = array(2, 4, 1, 1, 1, 2); $this->T128[] = array(1, 3, 4, 1, 1, 1); $this->T128[] = array(1, 1, 1, 2, 4, 2); $this->T128[] = array(1, 2, 1, 1, 4, 2); $this->T128[] = array(1, 2, 1, 2, 4, 1); $this->T128[] = array(1, 1, 4, 2, 1, 2); $this->T128[] = array(1, 2, 4, 1, 1, 2); $this->T128[] = array(1, 2, 4, 2, 1, 1); $this->T128[] = array(4, 1, 1, 2, 1, 2); $this->T128[] = array(4, 2, 1, 1, 1, 2); $this->T128[] = array(4, 2, 1, 2, 1, 1); $this->T128[] = array(2, 1, 2, 1, 4, 1); $this->T128[] = array(2, 1, 4, 1, 2, 1); $this->T128[] = array(4, 1, 2, 1, 2, 1); $this->T128[] = array(1, 1, 1, 1, 4, 3); $this->T128[] = array(1, 1, 1, 3, 4, 1); $this->T128[] = array(1, 3, 1, 1, 4, 1); $this->T128[] = array(1, 1, 4, 1, 1, 3); $this->T128[] = array(1, 1, 4, 3, 1, 1); $this->T128[] = array(4, 1, 1, 1, 1, 3); $this->T128[] = array(4, 1, 1, 3, 1, 1); $this->T128[] = array(1, 1, 3, 1, 4, 1); $this->T128[] = array(1, 1, 4, 1, 3, 1); $this->T128[] = array(3, 1, 1, 1, 4, 1); $this->T128[] = array(4, 1, 1, 1, 3, 1); $this->T128[] = array(2, 1, 1, 4, 1, 2); $this->T128[] = array(2, 1, 1, 2, 1, 4); $this->T128[] = array(2, 1, 1, 2, 3, 2); $this->T128[] = array(2, 3, 3, 1, 1, 1); $this->T128[] = array(2, 1); for ($i = 32; $i <= 95; $i++) { $this->Aset .= chr($i); } for ($i = 0; $i <= 31; $i++) { $this->Aset .= chr($i); } for ($i = 0; $i < 96; $i++) { $this->SetFrom .= chr($i); $this->SetTo .= chr(($i < 32) ? $i + 64 : $i - 32); } } public function code128A($x, $y, $code, $w, $h) { if ($code == '') { throw new Samo_Exception('Parameter [code] for function code128A is empty'); } $this->code128A_init(); $Aguid = ''; $iterations = strlen($code); for ($i = 0; $i < $iterations; $i++) { $needle = substr($code, $i, 1); $Aguid .= ((strpos($this->Aset, $needle) === false) ? "N" : "O"); } $crypt = ""; while ($code > "") { $made = strpos($Aguid, "N"); if ($made === false) { $made = strlen($Aguid); } $crypt .= chr(($crypt > "") ? 101 : 103); $crypt .= strtr(substr($code, 0, $made), $this->SetFrom, $this->SetTo); $code = substr($code, $made); $Aguid = substr($Aguid, $made); } $check = ord($crypt[0]); $iterations = strlen($crypt); for ($i = 0; $i < $iterations; $i++) { $check += (ord($crypt[$i]) * $i); } $check %= 103; $crypt .= chr($check) . chr(106) . chr(107); $i = (strlen($crypt) * 11) - 8; $modul = $w / $i; $iterations = strlen($crypt); for ($i = 0; $i < $iterations; $i++) { $c = $this->T128[ord($crypt[$i])]; $ccount = count($c); for ($j = 0; $j < $ccount; $j++) { $this->Rect($x, $y, $c[$j] * $modul, $h, "F"); $x += ($c[$j++] + $c[$j]) * $modul; } } } public function SetWidths($w) { $this->widths = $w; } public function SetAligns($a) { $this->aligns = $a; } public function RowTag($data, $height, $align = null, $fill = null, $draw_border = true) { $aligns = (!is_null($align)) ? array_fill(0, count($data), $align) : $this->aligns; $left = $this->GetX(); $nb = 0; $dataWithoutTags = preg_replace("|^(<([^>]+)>)|", '', preg_replace("|^(</([^>]+)>)|", '', $data)); $iterations = count($data); for ($i = 0; $i < $iterations; $i++) { $nb = max($nb, $this->_NbLines($this->widths[$i], $dataWithoutTags[$i])); } $h = $height * $nb; $this->_CheckPageBreak($h); $iterations = count($data); for ($i = 0; $i < $iterations; $i++) { $w = $this->widths[$i]; $a = isset($aligns[$i]) ? $aligns[$i] : 'L'; $x = $this->GetX(); $y = $this->GetY(); $this->WriteTag($w, $height, $data[$i], 0, $a, $fill); if ($draw_border) { $this->Rect($x, $y, $w, $h); } $this->SetXY($x + $w, $y); } $this->Ln($h); $this->SetX($left); } public function Row($data, $height, $align = null, $fill = null, $draw_border = true) { $aligns = (!is_null($align)) ? array_fill(0, count($data), $align) : $this->aligns; $left = $this->GetX(); $nb = 0; $iterations = count($data); for ($i = 0; $i < $iterations; $i++) { $nb = max($nb, $this->_NbLines($this->widths[$i], $data[$i])); } $h = $height * $nb; $this->_CheckPageBreak($h); $iterations = count($data); for ($i = 0; $i < $iterations; $i++) { $w = $this->widths[$i]; $a = isset($aligns[$i]) ? $aligns[$i] : 'L'; $x = $this->GetX(); $y = $this->GetY(); $this->MultiCell($w, $height, $data[$i], 0, $a, $fill); if ($draw_border) { $this->Rect($x, $y, $w, $h); } $this->SetXY($x + $w, $y); } $this->Ln($h); $this->SetX($left); } public function _CheckPageBreak($h) { if ($this->GetY() + $h > $this->PageBreakTrigger) { $left = $this->GetX(); $this->AddPage($this->CurOrientation); $this->SetX($left); } } public function _NbLines($w, $txt) { $cw =& $this->CurrentFont['cw']; if ($w == 0) { $w = $this->w - $this->rMargin - $this->x; } $wmax = ($w - 2 * $this->cMargin) * 1000 / $this->FontSize; $s = str_replace("\r", '', $txt); $nb = strlen($s); if ($nb > 0 and $s[$nb - 1] == "\n") { $nb--; } $sep = -1; $i = 0; $j = 0; $l = 0; $nl = 1; while ($i < $nb) { $c = $s[$i]; if ($c == "\n") { $i++; $sep = -1; $j = $i; $l = 0; $nl++; continue; } if ($c == ' ') { $sep = $i; } $l += $cw[$c]; if ($l > $wmax) { if ($sep == -1) { if ($i == $j) { $i++; } } else { $i = $sep + 1; } $sep = -1; $j = $i; $l = 0; $nl++; } else { $i++; } } return $nl; } public function _putstream($s) { if ($this->encrypted) { $s = $this->_RC4($this->_objectkey($this->n), $s); } parent::_putstream($s); } public function _textstring($s) { if ($this->encrypted) { $s = $this->_RC4($this->_objectkey($this->n), $s); } return parent::_textstring($s); } public function _objectkey($n) { return substr($this->_md5_16($this->encryption_key . pack('VXxx', $n)), 0, 10); } public function _escape($s) { $s = str_replace('\\', '\\\\', $s); $s = str_replace(')', '\\)', $s); $s = str_replace('(', '\\(', $s); $s = str_replace("\r", '\\r', $s); return $s; } public function _putencryptedresources() { if ($this->encrypted) { $this->_newobj(); $this->enc_obj_id = $this->n; $this->_out('<<'); $this->_putencryption(); $this->_out('>>'); $this->_out('endobj'); } } public function _putencryption() { $this->_out('/Filter /Standard'); $this->_out('/V 1'); $this->_out('/R 2'); $this->_out('/O (' . $this->_escape($this->Ovalue) . ')'); $this->_out('/U (' . $this->_escape($this->Uvalue) . ')'); $this->_out('/P ' . $this->Pvalue); } public function _puttrailer() { parent::_puttrailer(); if ($this->encrypted) { $this->_out('/Encrypt ' . $this->enc_obj_id . ' 0 R'); $this->_out('/ID [()()]'); } } public function _RC4($key, $text) { if ($this->last_rc4_key != $key) { $k = str_repeat($key, 256 / strlen($key) + 1); $rc4 = range(0, 255); $j = 0; for ($i = 0; $i < 256; $i++) { $t = $rc4[$i]; $j = ($j + $t + ord($k{$i})) % 256; $rc4[$i] = $rc4[$j]; $rc4[$j] = $t; } $this->last_rc4_key = $key; $this->last_rc4_key_c = $rc4; } else { $rc4 = $this->last_rc4_key_c; } $len = strlen($text); $a = 0; $b = 0; $out = ''; for ($i = 0; $i < $len; $i++) { $a = ($a + 1) % 256; $t = $rc4[$a]; $b = ($b + $t) % 256; $rc4[$a] = $rc4[$b]; $rc4[$b] = $t; $k = $rc4[($rc4[$a] + $rc4[$b]) % 256]; $out .= chr(ord($text{$i}) ^ $k); } return $out; } public function _md5_16($string) { return pack('H*', md5($string)); } public function _Ovalue($user_pass, $owner_pass) { $tmp = $this->_md5_16($owner_pass); $owner_RC4_key = substr($tmp, 0, 5); return $this->_RC4($owner_RC4_key, $user_pass); } public function _Uvalue() { return $this->_RC4($this->encryption_key, $this->padding); } public function _generateencryptionkey($user_pass, $owner_pass, $protection) { $user_pass = substr($user_pass . $this->padding, 0, 32); $owner_pass = substr($owner_pass . $this->padding, 0, 32); $this->Ovalue = $this->_Ovalue($user_pass, $owner_pass); $tmp = $this->_md5_16($user_pass . $this->Ovalue . chr($protection) . "\xFF\xFF\xFF"); $this->encryption_key = substr($tmp, 0, 5); $this->Uvalue = $this->_Uvalue(); $this->Pvalue = -(($protection ^ 255) + 1); } public function SetProtection($permissions = array(), $user_pass = '', $owner_pass = null) { $options = array('print' => 4, 'modify' => 8, 'copy' => 16, 'annot-forms' => 32); $protection = 192; foreach ($permissions as $permission) { if (!isset($options[$permission])) { $this->Error('Incorrect permission: ' . $permission); } $protection += $options[$permission]; } if ($owner_pass === null) { $owner_pass = uniqid(rand()); } $this->encrypted = true; $this->_generateencryptionkey($user_pass, $owner_pass, $protection); } public function Image($file, $x = null, $y = null, $w = 0, $h = 0, $type = '', $link = '') { if (strpos($file, _ROOT) === 0) { $file = str_replace(_ROOT, '', $file); } if (defined('CUSTOM')) { $tmp = '.dev/custom/' . CUSTOM . '/' . $file; if (file_exists($tmp)) { $file = $tmp; } } if (strpos($file, '\\') !== false) { throw new Samo_Exception('Use slash (/) as DIRECTORY_SEPARATOR instead of backslash (\) '); } $file = _ROOT . $file; return parent::Image($file, $x, $y, $w, $h, $type, $link); } public function debug() { try { $view = Samo_Registry::get('view'); if ($vars = $view->get_template_vars()) { $this->encrypted = false; foreach (array('routes', 'SCRIPT_NAME', 'WWWROOT', 'CURRENT_MODULE', 'logged', 'LOGIN_AGENCY_OFFICIAL_NAME', 'LOGIN_AGENCY_PARTNER_TYPE') as $index) { if (isset($vars[$index])) { unset($vars[$index]); } } $this->AddFont('courier', '', 'courier.php'); $this->page(); $pad = str_repeat('=', 50); $this->p($pad . 'Start debug' . $pad); $this->p(var_export($vars, true), 7); $this->p($pad . 'End debug' . $pad); } } catch (Exception $e) { $this->p('TEMPLATE VARS NOT ACCESSABLE'); } } public function _dochecks() { if (sprintf('%.1F', 1.0) != '1.0') { $this->Error('This version of PHP is not supported'); } } public function precompile_fpdf($src) { $canonical_hostname = preg_replace('~^(www\.).+~', '', Samo_Request::host()); $compile_suffix = Samo_Request::lang() . '_' . $canonical_hostname . '_' . crc32($src) . '_'; $compiled = SMARTY_COMPILE_DIR . $compile_suffix . basename($src) . '.tpl.php'; if (!file_exists($compiled) || filemtime($compiled) < filemtime($src)) { $source = file_get_contents($src); $wrapper = '<' . '?php
                $all_vars = array();
                if (!function_exists("_date_format")) {
                    function _date_format($format, $timestamp = null) {
                        if (is_object($timestamp)) {
                            return $timestamp->format($format);
                        }
                        return \date($format,(null == $timestamp) ? time() : $timestamp);
                    }
                    function samo_quotes_decode($txt){
                        if(is_string($txt)){
                            return htmlspecialchars_decode($txt, ENT_QUOTES);
                        }elseif(is_array($txt)){
                            return array_map("samo_quotes_decode",$txt);
                        }
                        return $txt;
                    }
                    $all_vars = $this->get_template_vars();
                    $all_vars = array_map("samo_quotes_decode",$all_vars);
                }
'; if (preg_match_all("~((include|require)(_once)?)\s+\(?['|\"](.+)['|\"]\)?~", $source, $matches)) { foreach ($matches[0] as $idx => $line) { $include = $matches[4][$idx]; if (basename($include) == $include) { $include = dirname($src) . '/' . $include; } $operator = $matches[1][$idx]; $source = str_replace($line, $operator . ' $pdf->precompile_fpdf("' . $include . '")', $source); } } if (preg_match('~(new|extends)\s+(tFPDF|Samo_tFPDF)~i', $source)) { $source = preg_replace('~\$all_vars = \$this->get_template_vars\(\);~i', '/* fixme */', $source); $source = preg_replace('~\$all_vars = array_map\(\'_toUTF\',\$all_vars\);~i', '/* fixme */', $source); $source = preg_replace('~extract\(\$all_vars\);~i', '/* fixme */', $source); $wrapper .= '
                    if (!function_exists("__toUTF")) {
                        function __toUTF($ele) {
                            if (is_array($ele)) {
                                return array_map("__toUTF",$ele);
                            }
                            return (!is_object($ele)) ? mb_convert_encoding($ele,"utf-8","cp1251") : $ele;
                        }
                        $all_vars = array_map("__toUTF",$all_vars);
                    }
'; } $wrapper .= '
                if (!isset($___extract_once)) {
                    extract($all_vars);
                    $___extract_once = true;
                }
                ?' . '>
'; $source = preg_replace('~date\s?\(~i', '_date_format(', $source); $source = $wrapper . $source; Samo_Utils::writeFile($compiled, $source); } return $compiled; } public function smarty_modifier_summa_to_str($L, $_als = 'rub') { if (!function_exists('smarty_modifier_summa_to_str')) { include _ROOT . 'includes/helpers/modifier.summa_to_str.php'; } return smarty_modifier_summa_to_str($L, $_als); } } 