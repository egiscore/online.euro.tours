<?php
 class Samo_Utils { static public function rm_rf($path) { if (is_dir($path)) { foreach (scandir($path) as $value) { if ($value != "." && $value != "..") { $value = $path . "/" . $value; if (is_dir($value)) { self::rm_rf($value); } elseif (is_file($value) && is_writable($value)) { unlink($value); } else { return false; } } } return rmdir($path); } else { if (is_file($path) && is_writable($path)) { return unlink($path); } return false; } } static public function exec_job($taskid = null) { if (defined('WWWROOT') && isset($_SERVER['SERVER_ADDR']) && isset($_SERVER['SERVER_PORT'])) { $cron_uri = WWWROOT . 'cron.php'; if (null !== $taskid) { $cron_uri .= '?task=' . $taskid; } $errno = ''; $errstr = ''; $CRON_HOST = defined('CRON_HOST') ? CRON_HOST : $_SERVER['SERVER_ADDR']; $CRON_PORT = defined('CRON_PORT') ? CRON_PORT : $_SERVER['SERVER_PORT']; if (false !== ($fh = @fsockopen($CRON_HOST, $CRON_PORT, $errno, $errstr, 0.01))) { fputs( $fh, "GET $cron_uri HTTP/1.0\r\n" . "Host: {$_SERVER['HTTP_HOST']}\r\n\r\n" ); fgets($fh, 32); fclose($fh); } } return true; } static public function assets_revision($calculate = false) { $revision = 0; $versionFile = SMARTY_COMPILE_DIR . '/VERSION'; $load_cache = function () { $registry = Samo_Registry::instance(); if (!isset($registry['cache'])) { try { Samo_Registry::load('cache', 'Samo_Cache'); } catch (Samo_Cache_Exception $e) { return Samo_Loader::load_object('Samo_Cache', 'null'); } } return $registry['cache']; }; if ($calculate) { $cwd = getcwd(); chdir(_ROOT); $files = ($tmp = glob('public/*/*')) ? $tmp : array(); $iconscss = 'data/search_tour/icons.css'; if (file_exists(_ROOT . $iconscss)) { $files[] = $iconscss; } $filemtimemax = 0; $last_modified_assets = null; foreach ($files as $file) { if (is_file($file)) { $filemtime = filemtime($file); if ($filemtime > $filemtimemax) { $filemtimemax = $filemtime; $last_modified_assets = $file; } } } $last_assets_version = crc32(md5_file($last_modified_assets)); $cache_exists = file_exists($versionFile); $revision = ($cache_exists) ? file_get_contents($versionFile) : $last_assets_version; if ($revision != $last_assets_version || !$cache_exists) { self::writeFile($versionFile, $last_assets_version); $cache = $load_cache(); $revision = $cache->set('ASSETS_VERSION', $last_assets_version, null, true); $cache->set('ASSETS', array(), null, true); } chdir($cwd); } if (0 == $revision) { $cache = $load_cache(); if (false === ($revision = $cache->get('ASSETS_VERSION'))) { if (file_exists($versionFile) && false !== ($revision = file_get_contents($versionFile))) { $revision = $cache->set('ASSETS_VERSION', $revision, null, true); } else { return call_user_func_array(__METHOD__, array($calculate => true)); } } } return $revision; } static public function writeFile($path, $content) { if ($result = @file_put_contents($path, $content, LOCK_EX)) { $umask = umask(0); @chmod($path, 0666); umask($umask); } return $result; } static public function generatePassword() { do { $pass = base64_encode(substr(pack('H*', md5(uniqid("", true))), 5, 6)); } while (substr_count($pass, '/') | substr_count($pass, '+')); return $pass; } static public function randomString($length = 8, $type = 'alnum') { switch ($type) { case 'alnum': $pool = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; break; case 'alpha': $pool = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; break; case 'hexdec': $pool = '0123456789abcdef'; break; case 'numeric': $pool = '0123456789'; break; default: $pool = (string)$type; break; } $random = function ($range) { if (function_exists('openssl_random_pseudo_bytes')) { $log = log($range, 2); $bytes = (int)($log / 8) + 1; $bits = (int)$log + 1; $filter = (int)(1 << $bits) - 1; do { $rnd = hexdec(bin2hex(openssl_random_pseudo_bytes($bytes))); $rnd = $rnd & $filter; } while ($rnd >= $range); } else { $rnd = mt_rand(0, $range); } return $rnd; }; $output = ""; $max = strlen($pool); for ($i = 0; $i < $length; $i++) { $output .= $pool[$random($max)]; } return $output; } static public function tempFile($prefix, $ext, $content, $dir = 'dnl') { if (!empty($ext) && false !== strpos($ext, '.')) { $ext = pathinfo(strtolower($ext), PATHINFO_EXTENSION); } if (empty($ext)) { $ext = 'bin'; } if (in_array($ext, array('exe', 'dll', 'so', 'php'))) { ErrorCode::UNSUPPORTED_FILETYPE(); } $filename = sprintf("%s_%s.%s", $prefix, self::randomString(9), $ext); $filepath = _ROOT . $dir . '/' . $filename; if (self::writeFile($filepath, $content)) { return WWWROOT . $dir . '/' . $filename; } return false; } static public function findFile($dir, $mask) { $return = false; $cwd = getcwd(); chdir($dir); $files = glob($mask); $newest = 0; if (is_array($files)) { if (1 == count($files)) { $return = reset($files); } else { foreach ($files as $file) { $filemtime = filemtime($file); if (!$return || $filemtime > $newest) { $return = $file; $newest = $filemtime; } } } } chdir($cwd); return $return; } static public function convert_bytes($val) { $val = trim($val); $last = strtolower($val[strlen($val) - 1]); $val = intval($val); switch ($last) { case 'p': $val *= 1024; case 't': $val *= 1024; case 'g': $val *= 1024; case 'm': $val *= 1024; case 'k': $val *= 1024; break; } return $val; } static public function ifs(...$args) { $ret = null; foreach ($args as $arg) { if ($ret = $arg) { break; } } return $ret; } static public function notnull(...$args) { $ret = null; foreach ($args as $arg) { if (null !== ($ret = $arg)) { break; } } return $ret; } } 