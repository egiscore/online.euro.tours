<?php
 define('ANDR_XML_CT_NONE', 0); define('ANDR_XML_CT_GZIP', 1); define('ANDR_XML_CT_ZLIB', 2); define('ANDR_XML_CT_STA', 4); class Andr_Xml extends SimpleXMLElement { public static function factory($xml, $compress_type = null) { if (is_object($xml) && ($xml instanceof DOMDocument)) { $sim = simplexml_import_dom($xml->documentElement, 'Andr_Xml'); } elseif (is_object($xml) && ($xml instanceof Andr_Xml)) { $sim = $xml; } elseif (is_array($xml)) { $sim = Andr_Xml::_toXml($xml); } else { try { $sim = simplexml_load_string($xml, 'Andr_Xml', LIBXML_NOXMLDECL); } catch (Exception $e) { $sim = false; } if (false === $sim) { $sim = simplexml_load_string(Andr_Xml::_unCompress($xml, (($compress_type) ? $compress_type : ANDR_XML_CT_STA)), 'Andr_Xml', LIBXML_NOXMLDECL); } } return $sim; } public function asArr() { return Andr_Xml::_fromXml($this); } public function getArr() { return $this->asArr(); } public function asDom() { $dom_sxe = dom_import_simplexml($this); $dom = new DOMDocument('1.0'); $dom_sxe = $dom->importNode($dom_sxe, true); $dom_sxe = $dom->appendChild($dom_sxe); return $dom; } public function getDom() { return $this->asDom(); } public function asXml($filename = null) { if (null === $filename) { $return = parent::asXml(); $return = preg_replace('/<\?xml.*?\?>\s*/', null, $return); return $return; } else { return parent::asXML($filename); } } public function getXml() { return $this->asXml(); } public function asStr($compress_type = null) { return Andr_Xml::_enCompress($this->asXml(), ((null !== $compress_type) ? $compress_type : ANDR_XML_CT_STA)); } public function getStr($compress_type = null) { return $this->asStr($compress_type); } public function toXml($data, $element) { return $this->_toXml($data, $element); } public function fromXml($element) { return $this->_fromXml($element); } public function setCompressType($compress_type) { return true; } private static function _enCompress($data, $compress_type) { switch ((string)$compress_type) { case ANDR_XML_CT_NONE: $return = $data; break; case ANDR_XML_CT_GZIP: $return = gzencode($data, 5); break; case ANDR_XML_CT_ZLIB: $return = base64_encode(gzcompress($data, 5)); break; case ANDR_XML_CT_STA: default: $data_len = strlen($data); $mask = 255; $data_length = chr($data_len & $mask); for ($i = 0; $i < 3; $i++) { $data_len = $data_len >> 8; $data_length = $data_length . chr($data_len & $mask); } $return = $data_length . gzcompress($data, 5); } return $return; } private static function _unCompress($data, $compress_type) { if (is_null($data)) { $return = null; } else { switch ((string)$compress_type) { case ANDR_XML_CT_NONE: $return = $data; break; case ANDR_XML_CT_GZIP: $return = gzinflate(substr($data, 10, -8)); break; case ANDR_XML_CT_ZLIB: $return = gzuncompress(substr(base64_decode($data), 4)); break; case ANDR_XML_CT_STA: default: $return = gzuncompress($data); } } return $return; } protected static function _toXml($params, $element = null) { if (null === $element) { if (is_array($params)) { $keys = array_keys($params); $key = array_shift($keys); if (is_numeric($key)) { unset($key); } else { $params = $params[$key]; } } if (!isset($key)) { $key = 'root'; } $element = new Andr_Xml('<' . $key . '/>'); unset($key); } if (is_array($params)) { foreach ($params as $key => $val) { if ($key == '_') { Andr_Xml::_toXml($val, $element); } else { if (is_array($val)) { if (array_key_exists(0, $val)) { foreach ($val as $k => $v) { if (is_numeric($k)) { Andr_Xml::_toXml($v, $element->addChild($key)); } } } else { if (array_key_exists('_', $val) && (null === $val['_'])) { unset($val['_']); if (empty($val)) { $val = null; } } if (null !== $val) { Andr_Xml::_toXml($val, $element->addChild($key)); } } } else { if (null !== $val) { $element->addAttribute($key, $val); } } } } } else { $element[0] = $params; } return $element; } protected static function _fromXml($element) { $arr = array(); foreach ($element->children() as $name => $child) { if ($name != '_compress_type') { $arr[$name][] = Andr_Xml::_fromXml($child); } } if (empty($arr)) { if ($element[0] != '') { $arr['_'] = (string)$element[0]; } } foreach ($element->attributes() as $name => $atr) { $arr[$name] = strDeConvert((string)$atr); } return $arr; } public function addAttributes(array $attributes, string $namespace = null) { foreach ($attributes as $name => $value) { if (is_scalar($value)) { $this->addAttribute($name, $value, $namespace); } } return $this; } public function addAttribute($name, $value = null, $namespace = null) { if (null !== $value) { parent::addAttribute($name, $this->_value($value), $namespace); } return $this; } public function setAttribute($name, $value) { $this[$name] = $this->_value($value); return $this; } private function _value($value) { if (is_bool($value)) { $value = ($value) ? 'true' : 'false'; } return $value; } public function remove($node = null) { if (null === $node) { $node = dom_import_simplexml($this); $node->parentNode->removeChild($node); return null; } elseif (count($this->{$node})) { unset($this->{$node}); } return $this; } public function move($path) { if ($target = reset($this->xpath($path))) { $node = dom_import_simplexml($this); $xml = dom_import_simplexml($target); if (!$node->parentNode->isSameNode($xml)) { $node->parentNode->removeChild($node); $xml->appendChild($node); } } return $this; } public function import($xml) { $node = dom_import_simplexml($this); $xml = dom_import_simplexml($xml); $xml = $node->ownerDocument->importNode($xml, true); $node->appendChild($xml); return $this; } public function addChilds($childs, $namespace = null) { foreach ($childs as $name => $value) { if (is_array($value)) { foreach ($value as $val) { $this->addChild($name, $val, $namespace); } } else { $this->addChild($name, $value, $namespace); } } return $this; } public function addChild($name, $value = null, $namespace = null) { if (is_string($value)) { $value = htmlspecialchars($value, ENT_NOQUOTES); } return parent::addChild($name, $value, $namespace); } public function validate($schema) { return dom_import_simplexml($this)->ownerDocument->schemaValidate($schema); } public function addChildWithCDATA($name, $cdata) { $node = $this->addChild($name); if ($cdata) { $node = dom_import_simplexml($node); $p = $node->ownerDocument; $node->appendChild($p->createCDATASection($cdata)); } return $this; } } 